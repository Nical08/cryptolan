<%
const currentPage = 'private';
const title = currentPeer ? `Chat con ${currentPeer.username || currentPeer.ip}` : 'Chat Privata';
%>

<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %> - P2P Chat</title>
    <link rel="stylesheet" href="/css/style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="header-content">
                <div class="logo">
                    <i class="fab fa-telegram"></i>
                    <span>P2P Secure Chat</span>
                </div>
                <nav class="nav">
                    <a href="/" class="nav-link">
                        <i class="fas fa-arrow-left"></i> Gruppo
                    </a>
                    <a href="/peers" class="nav-link">
                        <i class="fas fa-users"></i> Tutti i Peer
                    </a>
                    <span class="user-info">
                        <i class="fas fa-user"></i> <%= user.username %>
                        <span id="connectionStatus" class="status-indicator online"></span>
                    </span>
                </nav>
            </div>
        </header>

        <main class="main-content">
            <div class="chat-single-container">
                <% if (currentPeer) { %>
                <div class="chat-header-single">
                    <div class="peer-info-large">
                        <div class="peer-avatar-large">
                            <i class="fas fa-user"></i>
                        </div>
                        <div class="peer-details-large">
                            <h3><%= currentPeer.username || 'Sconosciuto' %></h3>
                            <p class="peer-address"><%= currentPeer.ip %>:<%= currentPeer.port %></p>
                            <div class="peer-status-info">
                                <span class="status-indicator <%= currentPeer.public_key ? 'encrypted' : 'plain' %>"></span>
                                <span><%= currentPeer.public_key ? 'Comunicazione cifrata' : 'Comunicazione in chiaro' %></span>
                                <span class="connection-status <%= currentPeer.isConnected ? 'connected' : 'disconnected' %>">
                                    <%= currentPeer.isConnected ? 'ðŸŸ¢ Connesso' : 'ðŸ”´ Disconnesso' %>
                                </span>
                            </div>
                        </div>
                    </div>
                    <div class="peer-actions-single">
                        <% if (!currentPeer.isConnected) { %>
                            <button class="btn btn-sm btn-primary" onclick="connectToPeer('<%= currentPeer.ip %>')">
                                <i class="fas fa-plug"></i> Connetti
                            </button>
                        <% } %>
                        <button class="btn btn-sm btn-outline" onclick="refreshChat()">
                            <i class="fas fa-sync-alt"></i> Aggiorna
                        </button>
                    </div>
                </div>
                
                <div class="messages-container-single" id="messagesContainer">
                    <% messages.forEach(message => { %>
                        <div class="message <%= message.direction === 'outgoing' ? 'outgoing' : 'incoming' %> private-message">
                            <div class="message-header">
                                <span class="sender">
                                    <% if (message.direction === 'outgoing') { %>
                                        ðŸ‘¤ Tu
                                    <% } else { %>
                                        ðŸ‘¤ <%= message.sender_username || 'Unknown' %>
                                    <% } %>
                                </span>
                                <span class="time"><%= new Date(message.timestamp).toLocaleTimeString() %></span>
                            </div>
                            <div class="message-content">
                                <%= message.message %>
                            </div>
                            <div class="message-footer">
                                <span class="message-type">ðŸ”’ Privato</span>
                            </div>
                        </div>
                    <% }); %>
                </div>
                
                <div class="message-input-container-single">
                    <form id="messageForm" class="message-form">
                        <input type="hidden" id="peerAddress" value="<%= currentPeer.ip %>:<%= currentPeer.port %>">
                        <div class="input-group">
                            <input type="text" id="messageInput" 
                                   placeholder="Scrivi un messaggio privato a <%= currentPeer.username || currentPeer.ip %>..." 
                                   maxlength="500"
                                   required>
                            <button type="submit" class="btn btn-primary" <%= !currentPeer.isConnected ? 'disabled' : '' %>>
                                <i class="fas fa-paper-plane"></i> Invia
                            </button>
                        </div>
                        <% if (!currentPeer.isConnected) { %>
                            <div class="connection-warning">
                                <i class="fas fa-exclamation-triangle"></i>
                                Non connesso. Il messaggio verrÃ  inviato quando la connessione sarÃ  disponibile.
                            </div>
                        <% } %>
                    </form>
                </div>
                <% } else { %>
                <div class="no-peer-selected">
                    <i class="fas fa-exclamation-triangle"></i>
                    <h3>Peer non trovato</h3>
                    <p>Il peer selezionato non Ã¨ piÃ¹ disponibile.</p>
                    <a href="/peers" class="btn btn-primary">Scegli un peer</a>
                </div>
                <% } %>
            </div>
        </main>

        <!-- Notifica toast per nuovi messaggi -->
        <div id="toast" class="toast hidden">
            <div class="toast-content">
                <span id="toastMessage"></span>
            </div>
        </div>

        <footer class="footer">
            <div class="footer-content">
                <p>P2P Secure Chat - Comunicazione crittata end-to-end</p>
            </div>
        </footer>
    </div>
    
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const currentPeerAddress = '<%= currentPeer ? `${currentPeer.ip}:${currentPeer.port}` : "" %>';
        let currentMessages = new Set();
        
        if (currentPeerAddress) {
            socket.emit('join-private', currentPeerAddress);
        }
        
        // Gestione invio messaggi privati
        document.getElementById('messageForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const messageInput = document.getElementById('messageInput');
            const peerAddress = document.getElementById('peerAddress').value;
            const message = messageInput.value.trim();
            
            if (!message) return;
            
            try {
                const response = await fetch('/api/send-private-message', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        message: message,
                        peerAddress: peerAddress
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    messageInput.value = '';
                } else {
                    console.error('Errore invio messaggio privato:', data.error);
                    showToast('Errore nell\'invio del messaggio: ' + data.error, 'error');
                }
            } catch (error) {
                console.error('Errore invio messaggio:', error);
                showToast('Errore di connessione', 'error');
            }
        });
        
        // ðŸ“¨ RICEZIONE MESSAGGI PRIVATI IN TEMPO REALE
        socket.on('new-private-message', (data) => {
            // Mostra solo i messaggi per questa chat privata
            if (data.peerAddress === currentPeerAddress) {
                addPrivateMessageToChat(data);
                showNewMessageNotification(data);
            }
        });
        
        function addPrivateMessageToChat(data) {
            // Evita duplicati
            if (currentMessages.has(data.id)) return;
            currentMessages.add(data.id);
            
            const messagesContainer = document.getElementById('messagesContainer');
            const messageElement = document.createElement('div');
            messageElement.className = `message ${data.direction === 'outgoing' ? 'outgoing' : 'incoming'} private-message`;
            messageElement.innerHTML = `
                <div class="message-header">
                    <span class="sender">
                        ${data.direction === 'outgoing' ? 'ðŸ‘¤ Tu' : `ðŸ‘¤ ${data.sender}`}
                    </span>
                    <span class="time">${new Date(data.timestamp).toLocaleTimeString()}</span>
                </div>
                <div class="message-content">
                    ${data.message}
                </div>
                <div class="message-footer">
                    <span class="message-type">ðŸ”’ Privato</span>
                </div>
            `;
            
            messagesContainer.appendChild(messageElement);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Mantieni solo gli ultimi 100 ID
            if (currentMessages.size > 100) {
                const first = Array.from(currentMessages)[0];
                currentMessages.delete(first);
            }
        }
        
        // Notifiche di sistema
        socket.on('system-notification', (data) => {
            console.log('Notifica di sistema:', data.message);
            if (data.type === 'connection') {
                showToast(data.message, 'info');
            }
        });
        
        // Funzione per mostrare notifiche toast
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            
            toastMessage.textContent = message;
            toast.className = `toast toast-${type} show`;
            
            setTimeout(() => {
                toast.className = 'toast hidden';
            }, 3000);
        }
        
        // Notifica per nuovi messaggi
        function showNewMessageNotification(data) {
            if (!document.hasFocus()) {
                showToast(`Nuovo messaggio da ${data.sender}: ${data.message}`, 'message');
            }
        }
        
        // Funzioni di utilitÃ 
        async function connectToPeer(ip) {
            try {
                const response = await fetch('/api/connect-peer', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ ip: ip })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showToast('Connessione avviata!', 'success');
                    setTimeout(() => {
                        location.reload();
                    }, 1000);
                } else {
                    showToast('Errore: ' + data.error, 'error');
                }
            } catch (error) {
                console.error('Errore connessione:', error);
                showToast('Errore di connessione', 'error');
            }
        }
        
        function refreshChat() {
            location.reload();
        }
        
        // Carica messaggi privati
        async function loadPrivateMessages() {
            try {
                const response = await fetch(`/api/private-messages/${currentPeerAddress}`);
                const data = await response.json();
                
                if (data.success) {
                    const messagesContainer = document.getElementById('messagesContainer');
                    messagesContainer.innerHTML = '';
                    currentMessages.clear();
                    
                    data.messages.forEach(message => {
                        const messageElement = document.createElement('div');
                        messageElement.className = `message ${message.direction === 'outgoing' ? 'outgoing' : 'incoming'} private-message`;
                        messageElement.innerHTML = `
                            <div class="message-header">
                                <span class="sender">
                                    ${message.direction === 'outgoing' ? 'ðŸ‘¤ Tu' : `ðŸ‘¤ ${message.sender_username || 'Unknown'}`}
                                </span>
                                <span class="time">${new Date(message.timestamp).toLocaleTimeString()}</span>
                            </div>
                            <div class="message-content">
                                ${message.message}
                            </div>
                            <div class="message-footer">
                                <span class="message-type">ðŸ”’ Privato</span>
                            </div>
                        `;
                        messagesContainer.appendChild(messageElement);
                    });
                    
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    showToast('Messaggi aggiornati', 'success');
                }
            } catch (error) {
                console.error('Errore caricamento messaggi:', error);
                showToast('Errore nel caricamento dei messaggi', 'error');
            }
        }
        
        // Auto-scroll iniziale
        window.addEventListener('load', () => {
            const messagesContainer = document.getElementById('messagesContainer');
            if (messagesContainer) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        });
    </script>
</body>
</html>